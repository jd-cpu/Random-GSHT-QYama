<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>이식혈관외과 랜덤 질문야마 퀴즈</title>
  <link rel="manifest" href="manifest.json?v=5">
  <meta name="theme-color" content="#4CAF50">
  <style>
    body { font-family: Arial, sans-serif; max-width:800px; margin:20px auto; padding:16px; text-align:center; }
    header { display:flex; justify-content:space-between; align-items:center; gap:12px; }
    h1 { margin:0; font-size:1.25rem; }
    #status { color:#666; font-size:0.95rem; margin-top:8px; text-align:left; }
    .question { margin:20px 0; font-size:1.15rem; white-space:pre-line; text-align:left; }
    .answer { margin-top:10px; font-weight:600; color:#0a6; white-space:pre-line; display:none; text-align:left; }
    .controls { margin-top:18px; }
    button { padding:10px 14px; margin:6px; font-size:1rem; }
    .progress-wrap { margin-top:14px; text-align:left; }
    .progress-info { font-size:0.92rem; color:#444; margin-bottom:6px; }
    .progress-bar { width:100%; height:12px; background:#eee; border-radius:8px; overflow:hidden; }
    .progress-inner { height:100%; width:0%; background:#4caf50; transition: width 0.25s ease; }
    small.note { display:block; color:#888; margin-top:8px; text-align:left; }
  </style>
</head>
<body>
  <header>
    <h1>이식혈관외과 랜덤 질문야마 퀴즈</h1>
    <div>
      <button id="btnToggleMode">복습 모드로</button>
      <button id="btnReset">초기화</button>
    </div>
  </header>

  <div id="status" aria-live="polite">로딩 중...</div>

  <div class="question" id="question">문제가 여기에 표시됩니다.</div>
  <div class="answer" id="answer"></div>

  <div class="controls" id="controls">
    <button id="btnShowAnswer">정답 보기</button>
    <button id="btnMarkWrong">오답 저장</button>
    <button id="btnPrev">이전 문제</button>
    <button id="btnNext">다음 문제</button>
    <!-- 복습 모드에서 첫 문제로 돌아가기 버튼 -->
    <button id="btnRestartReview" style="display:none;">복습 첫 문제로</button>
    <!-- 복습 모드에서 오답 제거 버튼 -->
    <button id="btnRemoveWrong" style="display:none;">오답 제거</button>
  </div>

  <div class="progress-wrap">
    <div class="progress-info" id="progressInfo">진행: 0 / 0 (남음: 0)</div>
    <div class="progress-bar"><div id="progressInner" class="progress-inner"></div></div>
    <small class="note">※ 정답 보기 버튼은 정답만 보여줍니다. 다음 문제로 이동하려면 '다음 문제' 버튼을 누르세요.</small>
  </div>

<script>
  // 기존 문제 데이터
  const questions = [
    { q: "(AVF 수술 중)교과서적으로는 AVF는 4-6주 뒤에 이용 가능하고, AVG는 그거보다 더 빨리 이용 가능하다고 나와있어. 왜 AVF는 그 정도 걸리는 걸까?", a: "혈관이 maturation 되어야 해서 그렇습니다." },
    { q: "(AVF 수술 중)교과서적으로는 AVF는 4-6주 뒤에 이용 가능하고, AVG는 그거보다 더 빨리 이용 가능하다고 나와있어. 왜 AVG는 AVF에 비해 더 빨리 이용 가능해?", a: "AVG는 애초에 graft를 이용하는 거라 maturation이 필요 없습니다." },
    { q: "(AVF 수술 중)손목부터 artery 이름 쭉 대봐", a: "<img 1>" },
    { q: "(AVF 수술 중)손목부터 vein 이름 쭉 대봐", a: "<img 2>" },
    { q: "(AVF 수술 중)AVF 수술이 무엇인가?", a: "정맥과 동맥을 직접 연결해서 투석환자의 경우 투석을 용이하게 만들어 주는 시술입니다." },
    { q: "(AVF 수술 중)AVF 수술이 어떻게 투석을 용이하게 만들어 주지?", a: "혈액투석을 할 때 체내에서 혈액이 나와서 다시 몸 내부로 돌아가는데, 이때 많은 양의 혈액이 빠르게 들어오기 때문에 이러한 속도와 압력을 버틸 수 있도록 정맥의 혈관벽을 두껍고 강하게 만들어 주기 위해서입니다. <br>동맥과 정맥을 연결해서 정맥으로 높은 압력의 동맥의 혈액을 다량 흐르게 만들어 정맥을 튼튼하게 해 줍니다." },
    { q: "(KT 수술 중)여기 산낙지처럼 만지면 팔딱이지? 이게 뭐야?", a: "Ureter입니다." },
    { q: "(Popliteal artery entrapment syndrome 수술 중)환자의 진단명과 수술하는 이유는?", a: "Popliteal artery entrapment syndrome은 popliteal artery가 주변 근육에 눌려 막히는 것으로, 이를 해결하기 위해 distal superficial femoral artery와 tibioperoneal trunk를 bypass로 연결해주는 수술입니다." },
    { q: "(Lt. femoral - popliteal bypass 수술 중)동맥은 구멍 조금만 뚫려도 피가 철철 나는데 왜 정맥은 잘라내도 피가 안 나?", a: "정맥은 valve가 있기 때문입니다." },
    { q: "(AVF revision 수술 중)이 수술 이름이 뭐야? 왜 하는 거지?", a: "AVF revision은 이미 있는 AVF를 수정하는 수술입니다." },
    { q: "AVF revision이 필요하게 되는 이유는 무엇인가?", a: "수술로 만들어진 동정맥루에 시간이 지나면서 협착이 일어나거나, 혈전이 생기거나, 동맥류가 발생하는 경우 투석이 어려워지거나 불가능해집니다. 이러한 경우 동정맥루를 수정하는 AVF revision 수술을 시행합니다." },
    { q: "(AVF 수술 중)이 환자는 왜 왼쪽, 오른쪽 둘 다 AVF 할까?", a: "혈액투석을 하며 steal syndrome이 발생했기 때문입니다." },
    { q: "Steal syndrome이란? (정의, 증상, 치료)", a: "Steal syndrome은 동정맥루나 AVG를 통해 흐르는 혈류가 너무 많아져서, 손이나 팔의 말초 조직에 공급되어야 할 혈액을 빼앗아 가는 현상입니다. <br>증상으로는 투석하지 않을 때에도 나타나는 손이나 팔의 통증, 냉감 및 저릿저릿한 형태의 감각 이상, 근육 위축, 피부 궤양이나 괴사 등이 있습니다. <br>치료로는 혈관의 직경을 줄여 혈류를 조정하는 혈관 묶기(banding), 동정맥루를 차단하고, 그보다 더 먼 곳에 있는 동맥에서 혈관을 이식하여 혈류를 재건하는 DRIL(distal revascularization with interval ligation), 동정맥루 폐쇄 후 신규 AVF/AVG가 있습니다." },
    { q: "(AVF 수술 중)Internal mammary artery로 CABG한 환자는 왜 AVF 하면 안될까?", a: "Internal mammary artery로 CABG한 경우 심장근육에 혈류를 공급하는 중요한 역할을 하게 되는데, AVF를 할 경우 심근 혈류 공급이 감소할 수 있기 때문입니다." },
    { q: "(AVF 수술 중)CABG에 활용하는 혈관에는 뭐가 있어?", a: "Saphenous vein, radial artery, internal mammary artery, gastroepiploic artery" },
    { q: "(AVF 수술 중)AVF시 thrill은 왜 생겨?", a: "Blood flow가 강한 동맥과, flow가 약한 정맥이 합쳐져 turbulent flow가 생기기도 하고, blood flow 자체가 강해지기 때문입니다." },
    { q: "(AVF 수술 중)Cephalic vein이 어디로 이어져? 걔는 뭐랑 뭐가 만나는 거야?", a: "Subclavian vein으로 이어지고, axillary vein과 cephalic vein이 합쳐서 subclavian vein이 됩니다." },
    { q: "(AVF 수술 중)Cephalic vein이 심장으로 가려면 뭐뭐 거쳐야 해?", a: "Brachiocephalic vein, superior vena cava" },
    { q: "(AVF 수술 중)Vertebral artery는 어디에서 나와?", a: "Subclavian artery" },
    { q: "(AVF 수술 중)Ulnar nerve, median nerve, radial nerve 각각 손상됐을 때 나타나는 손 모양이 뭐야?", a: "Ulnar nerve: claw hand(네 번째와 다섯 번째 손가락의 마디가 구부러지고 손가락 사이 근육이 위축되어 손이 갈고리 모양으로 변형됨) <br>Median nerve: ape hand(엄지손가락을 손바닥 안쪽으로 움직이지 못함), hand of benediction(주먹을 쥐려고 할 때 엄지, 검지, 중지가 제대로 굽혀지지 않아 축복을 내리는 듯한 모양이 됨) <br>Radial nerve: wrist drop(손목과 손가락을 위로 들어올리지 못하고 손목이 아래로 축 늘어짐)" },
    { q: "(AVF 수술 중)Hemodynamic한 문제에 의한 상지 허혈 질환에는 대표적으로 뭐가 있어?", a: "Thoracic outlet syndrome, steal syndrome" },
    { q: "Thoracic outlet syndrome의 정의와 증상은?", a: "쇄골과 첫 번째 갈비뼈 사이에 위치한 thoracic outlet에서 신경이나 혈관이 압박되는 질환으로, 신경 압박이 가장 흔하며 팔과 손에 저림, 통증, 감각 이상, 근력 약화 등의 증상이 나타납니다. <br>동맥이 압박될 경우 팔과 손이 차갑고 창백해지며, 손가락 끝이 시릴 수 있습니다. <br>정맥이 압박되는 경우 팔이 붓고 피부색이 푸르스름해지며 통증을 동반할 수 있습니다." },
    { q: "(AVG 수술 중)혈액투석을 위해서는 AVG, AVF 말고 다른 방법은 없나?", a: "Permanent catheterization을 통해 투석을 시도할 수는 있겠지만, AVF/AVG 외의 근본적인 방법은 없습니다." },
    { q: "(AVG 수술 중)AVG의 가장 중요한 complication에는 뭐가 있어?", a: "Heart failure, ischemia(steal syndrome), 면역반응(graft이기 때문)" },
    { q: "(AVG 수술 중 한 쪽만 연결한 graft를 들어올리며)이 이상 올리면 피가 안 나오는데 이게 뭐야?", a: "Central venous pressure" },
    { q: "(AVG 수술 중)Central venous pressure, CVP가 뭘 보기 위한 거야?", a: "Preload" },
    { q: "(AVG 수술 중)Preload의 문제를 확인하는 다른 방법은?", a: "P/Ex 중 skin 눌러보기, tongue hydration 확인하기, conjunctival edema 확인하기 등이 있습니다." },
    { q: "Endarterectomy는 무슨 수술인가?", a: "동맥내막절제술로, 동맥의 내막에 쌓인 죽상동맥경화 plaque를 외과적으로 제거하여 혈액 흐름을 복원하는 수술이다." },
    { q: "(Endarterectomy 중 혈관을 꿰매며)지금 뭐하는 거야?", a: "Adventitia와 media를 꿰매고 있습니다." },
    { q: "(Endarterectomy 중)Adventitia와 media를 왜 꿰매지?", a: "Dissection을 방지하기 위해서입니다." },
    { q: "(Revascularization 중)PTA의 full-term이 뭐야?", a: "Percutaneous transluminal angioplasty" },
    { q: "Percutaneous transluminal angioplasty란?", a: "좁아지거나 막힌 혈관을 넓히기 위해 사용되는 비수술적 시술로, 혈관의 플라크를 직접 제거하는 동맥내막절제술과 달리, 카테터와 풍선을 이용해 혈관을 확장한다." },
    { q: "Paclitaxel은 약리학적으로, 그리고 기능적으로 무슨 계열 항암제이지?", a: "약리학적으로 taxane 계열, 기능적으로는 antiproliferative 항암제입니다." },
    { q: "(Revascularization 환자의 revision 수술 중, ASO 있어서 media 잘라내고 그 부분을 graft로 대체하며)이게 뭘로 만든 거야?", a: "소의 심장 판막으로 만든 biograft" },
    { q: "ASO의 full-term과 의미는?", a: "Arteriosclerosis obliterans, 폐쇄동맥경화증" },
    { q: "(LDKT 수술 중)오줌은 더러운데 이렇게 복강에 오줌 줄줄 흘려도 돼?", a: "오줌은 ureter까지는 aseptic하고, cyst와 urethra는 outer organ이라 거기에 있는 상재균이 더러운 것이다. 따라서 상관이 없다." },
    { q: "(Rt. AVF cephalic vein transposition 중)수술 왜 하는 거야?", a: "Cephalic arch의 stenosis 있어, stenosis 있는 부위 아래쪽의 cephalic vein을 잘라서 basilic vein에 연결해 주기 위해서이다." },
    { q: "(Rt. AVF cephalic vein transposition 중)혈관외과 수술에서 transposition, interposition이 한글로 각각 뭘까?", a: "전위, 중간에 끼워넣는 것" },
    { q: "(Rt. AVF cephalic vein transposition 중)Umbilical vein의 remnant는?", a: "Ligamentum teres" },
    { q: "(KT 수술 중, 신장 이식 후 혈관 문합부를 만져보게 한 뒤)뭐가 느껴져? 그게 왜 나타나지?", a: "Pulse도 있지만 thrill이 있다, artery와 vein을 있는 AVF의 경우와 마찬가지로, artery와 artery 간의 압력 차이로 인해 thrill이 발생한다." },
    { q: "(KT 수술 중)AVF에서는 end to end인가, end to side인가?", a: "End to side입니다." },
    { q: "(KT 수술 중)지금 신장의 artery를 어디에 연결중이야?", a: "Internal iliac artery가 1st choice, 이 환자의 경우 internal iliac artery에 calcification 있어 external iliac artery에 연결함" }
  ];

  const KEY = {
    WRONG: 'quiz_wrong_v1',
    MODE: 'quiz_mode_v1',
    NORMAL_ORDER: 'quiz_normal_order_v1',
    NORMAL_IDX: 'quiz_normal_idx_v1',
    REVIEW_ORDER: 'quiz_review_order_v1',
    REVIEW_IDX: 'quiz_review_idx_v1'
  };

  let wrongList   = JSON.parse(localStorage.getItem(KEY.WRONG) || '[]');
  let mode        = localStorage.getItem(KEY.MODE) || 'normal';
  let orderNormal = JSON.parse(localStorage.getItem(KEY.NORMAL_ORDER) || 'null');
  let idxNormal   = parseInt(localStorage.getItem(KEY.NORMAL_IDX) || '0', 10);
  let orderReview = JSON.parse(localStorage.getItem(KEY.REVIEW_ORDER) || 'null');
  let idxReview   = parseInt(localStorage.getItem(KEY.REVIEW_IDX) || '0', 10);

  const elStatus          = document.getElementById('status');
  const elQuestion        = document.getElementById('question');
  const elAnswer          = document.getElementById('answer');
  const elBtnShow         = document.getElementById('btnShowAnswer');
  const elBtnWrong        = document.getElementById('btnMarkWrong');
  const elBtnNext         = document.getElementById('btnNext');
  const elBtnPrev         = document.getElementById('btnPrev');
  const elBtnToggle       = document.getElementById('btnToggleMode');
  const elBtnReset        = document.getElementById('btnReset');
  const elProgressInfo    = document.getElementById('progressInfo');
  const elProgressInner   = document.getElementById('progressInner');
  const elBtnRestartReview= document.getElementById('btnRestartReview');
  const elBtnRemoveWrong  = document.getElementById('btnRemoveWrong');

  function shuffledArray(n){
    const arr = Array.from({length:n}, (_,i)=>i);
    for(let i=arr.length-1;i>0;i--){
      const j=Math.floor(Math.random()*(i+1));
      [arr[i],arr[j]]=[arr[j],arr[i]];
    }
    return arr;
  }

  function saveAll(){
    localStorage.setItem(KEY.WRONG, JSON.stringify(wrongList));
    localStorage.setItem(KEY.MODE, mode);
    if(orderNormal) localStorage.setItem(KEY.NORMAL_ORDER, JSON.stringify(orderNormal));
    localStorage.setItem(KEY.NORMAL_IDX, String(idxNormal));
    if(orderReview) localStorage.setItem(KEY.REVIEW_ORDER, JSON.stringify(orderReview));
    localStorage.setItem(KEY.REVIEW_IDX, String(idxReview));
  }

  function clearAll(){
    localStorage.removeItem(KEY.WRONG);
    localStorage.removeItem(KEY.MODE);
    localStorage.removeItem(KEY.NORMAL_ORDER);
    localStorage.removeItem(KEY.NORMAL_IDX);
    localStorage.removeItem(KEY.REVIEW_ORDER);
    localStorage.removeItem(KEY.REVIEW_IDX);
    wrongList = [];
    mode = 'normal';
    orderNormal=null; orderReview=null;
    idxNormal=0; idxReview=0;
  }

  function ensureOrders(skipShuffle=false){
    // ✅ 일반 모드 순서 보장 (기본: 처음 한 번 섞고 고정)
    if(!Array.isArray(orderNormal) || orderNormal.length !== questions.length){
      orderNormal = Array.from({length: questions.length}, (_,i)=>i);
      if(!skipShuffle){
        orderNormal.sort(()=>Math.random()-0.5);
      }
    }

    // ✅ 복습 모드 순서 보장
    if(!Array.isArray(orderReview) || orderReview.length !== wrongList.length){
      orderReview = Array.from({length: wrongList.length}, (_,i)=>i);
    }

    // ✅ 인덱스 보정
    idxNormal = Math.min(Math.max(0, idxNormal), Math.max(0, orderNormal.length-1));
    idxReview = Math.min(Math.max(0, idxReview), Math.max(0, wrongList.length-1));
  }

  function currentListAndIndex(){
    if(mode==='normal'){
      return {listType:'normal', order:orderNormal, idx:idxNormal, total:orderNormal.length};
    } else {
      return {listType:'review', order:orderReview, idx:idxReview, total:orderReview.length};
    }
  }

  function getCurrentQuestion(){
    const info = currentListAndIndex();
    if(info.total===0) return null;
    if(info.listType==='normal'){
      return questions[info.order[info.idx]];
    } else {
      return wrongList[info.order[info.idx]];
    }
  }

  function updateProgressBar(idx,total,percent){
    elProgressInfo.innerText=`진행: ${idx}/${total}  (${percent}%)`;
    elProgressInner.style.width=total===0?'0%':`${percent}%`;
  }

  function updateToggleText(){
    elBtnToggle.textContent = mode==='normal'?`복습 모드 (${wrongList.length})`:'일반 모드로';
  }

  function render(skipShuffle=false){
    ensureOrders(skipShuffle);
    saveAll();
    const info=currentListAndIndex();

    // 버튼 표시
    if(mode==='review' && info.total>0){
      elBtnRestartReview.style.display='inline-block';
      elBtnRemoveWrong.style.display='inline-block';
    } else {
      elBtnRestartReview.style.display='none';
      elBtnRemoveWrong.style.display='none';
    }

    if(info.total===0){
      elStatus.innerText = mode==='normal'? '문제가 비어있습니다. questions 배열을 채워주세요.' : '복습할 문제가 없습니다.';
      elQuestion.innerText = mode==='normal'? '문제가 없습니다.' : '복습할 문제가 없습니다.';
      elAnswer.style.display='none';
      updateProgressBar(0,info.total,0);
      updateToggleText();
      return;
    }

    // 완료 상태
    if(info.idx >= info.total){
      elQuestion.innerText='모든 문제가 완료되었습니다.';
      elAnswer.style.display='none';
      updateProgressBar(info.total, info.total, 100);
      updateToggleText();
      return;
    }

    const cur = getCurrentQuestion();
    if(!cur){
      elQuestion.innerText='문제가 없습니다.';
      elAnswer.style.display='none';
      updateProgressBar(info.idx,info.total,Math.round((info.idx/Math.max(1,info.total))*100));
      updateToggleText();
      return;
    }

    elQuestion.innerHTML = cur.q;
    elAnswer.innerHTML = cur.a;
    elAnswer.style.display='none';

    const currentNumber=info.idx+1;
    const remaining=Math.max(0,info.total-info.idx-1);
    elStatus.innerText=`모드: ${mode==='normal'?'일반':'복습'}  •  ${currentNumber} / ${info.total}  (남음: ${remaining})`;
    updateProgressBar(info.idx, info.total, Math.round((info.idx/Math.max(1,info.total))*100));
    updateToggleText();
  }

  function showAnswer(){
    const cur = getCurrentQuestion();
    if(!cur) return;
    elAnswer.style.display='block';
  }

  function markWrong(){
    const info=currentListAndIndex();
    if(info.total===0 || info.idx>=info.total) return;
    const cur=getCurrentQuestion();
    if(!cur) return;
    if(!wrongList.some(it=>it.q===cur.q && it.a===cur.a)){
      wrongList.push({q:cur.q,a:cur.a});
      orderReview = Array.from({length: wrongList.length}, (_,i)=>i); // 새로 고정
      idxReview=Math.min(idxReview, orderReview.length-1);
      saveAll();
      updateToggleText();
    }
  }

  function removeWrong(){
    const cur = getCurrentQuestion();
    if(!cur) return;
    if(removeFromWrongListByQA(cur.q, cur.a)){
      render();
    }
  }

  function nextQuestion(){
    const info=currentListAndIndex();
    if(info.total===0){ render(); return; }
    if(info.listType==='normal'){
      idxNormal++;
      if(idxNormal>info.total) idxNormal=info.total;
    } else {
      idxReview++;
      if(idxReview>info.total) idxReview=info.total;
    }
    saveAll();
    render();
  }

  function prevQuestion(){
    const info=currentListAndIndex();
    if(info.total===0){ render(); return; }
    if(info.listType==='normal'){
      if(idxNormal<=0) return;
      idxNormal = Math.max(0, idxNormal-1);
      const prev = questions[orderNormal[idxNormal]];
      if(prev) removeFromWrongListByQA(prev.q,prev.a);
    } else {
      if(idxReview<=0) return;
      idxReview=Math.max(0, idxReview-1);
    }
    saveAll();
    render();
  }

  function removeFromWrongListByQA(q,a){
    const i = wrongList.findIndex(it => it.q === q && it.a === a);
    if(i!==-1){
      wrongList.splice(i,1);
      // 순서 재구성 및 인덱스 보정
      orderReview = Array.from({length: wrongList.length}, (_,k)=>k);
      if(idxReview >= wrongList.length){
        idxReview = Math.max(0, wrongList.length - 1);
      }
      saveAll();
      updateToggleText();
      return true;
    }
    return false;
  }

  function restartReview(){
    idxReview=0;
    saveAll();
    render();
  }

  function toggleMode(){
    mode = (mode==='normal')?'review':'normal';
    localStorage.setItem(KEY.MODE, mode);
    if(mode==='review' && wrongList.length===0){
      alert('복습할 오답이 없습니다.');
      mode='normal';
      localStorage.setItem(KEY.MODE, mode);
      return;
    }
    ensureOrders();
    render();
  }

  function resetProgress(){
    if(!confirm('진행 상황(섞인 순서 및 인덱스)과 오답 목록을 초기화할까요?')) return;
    clearAll();
    ensureOrders();
    saveAll();
    render();
  }

  elBtnShow.addEventListener('click', showAnswer);
  elBtnWrong.addEventListener('click', markWrong);
  elBtnNext.addEventListener('click', nextQuestion);
  elBtnPrev.addEventListener('click', prevQuestion);
  elBtnToggle.addEventListener('click', toggleMode);
  elBtnReset.addEventListener('click', resetProgress);
  elBtnRestartReview.addEventListener('click', restartReview);
  elBtnRemoveWrong.addEventListener('click', removeWrong);

  if('serviceWorker' in navigator){
    window.addEventListener('load', ()=>{
      navigator.serviceWorker.register('sw.js?v=5').catch(e=>{
        console.warn('ServiceWorker 등록 실패:', e);
      });
    });
  }

  ensureOrders();
  render();
</script>
</body>
</html>
